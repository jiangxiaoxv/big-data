# big-data
1. 学习路径
  https://www.bilibili.com/video/BV135411P7Ea?spm_id_from=333.788.player.switch&vd_source=5e17c856bfb7fe8e3c8387a111dcc329&p=2
2. JRE -- java Runtime（包含jvm + 核心类库）
3. JDK -- java Development Kit -- java开发工具包，开发工具 + JRE
4. JVM --jva virtual machine --java 虚拟机，是java能够跨平台的前提
5. java的技术结构
   JAVASE -- standard Edtion -- 标准版
   JAVAEE -- enterprise Edtion -- 企业版
   JAVAME -- Micro Edition -- 微型版
6. javac + 编译的java文件
7. java + 编译后的字节码文件
8. public 公共类必须和文件名一致
9. package 文件夹表示包
   java page.DemoClass page表示包
   javac -d E:\\Demo.java
   javac -d 表示在编译的时候需要将包生成对应的文件夹
10. java 中有53个关键字 --2个保留字  goto,const
    所有关键字都是小写的
11. 标识符 可以使用字母（常见语言的基本字符）、数字、_、$，但是要尽量减少使用
   不能使用关键字、数字不能开头、可以使用中文、区分大小写、驼峰命名发
   类名/接口名：
   变量/方法
   常量：HELLO_WORLD
   包: 都小写用.隔开
   main是标识符，不是关键字
12. javadoc + java文件 生成方法使用文档（/**   */）
13. 字面量
    整数常量： 所有的整数
    小数常量： 所有的小数
    字符常量：将一个字母、数字、符号用'' 标识起来 'a'
    字符串常量：将一个或者多个字符用“”标识起来 "abc"
    布尔常量： true、false
    空常量： null
14. 进制
    计数方式
    二进制: 从JDK1.7开始，允许在程序中定义二进制数字---以0b/0B作为开头 0b000111
    八进制: 要求以0作为开头
    十进制: 
    十六进制: 要求以0x/0X开头；0-9，a-f；
15. 进制转化
    十进制转化二进制：不断除以2；余数倒着排列
    二进制转化为十进制：从低位次开始，按位次乘以2的位次次幂，然后求和 1101 = 1 * 2^0 + 0 * 2^1 +  1 * 2^2 + 1 * 2^3
    十进制向其他进制转化：除以对应的进制，然后取余数倒排
    其他进制向十进制转化：从低位次开始，按位次乘以进制的位次次幂，然后求和
    二进制向八进制转化：从低位次开始，每三位二进制划分为一组，产生一个八进制数字，不足三位用零补充
    八进制向二进制转化：一变三，每一位八进制都会产生三位二进制数字，不足三位补0
    二进制向十六进制转化：四变一
    十六进制向二进制转化：一变四
16. 小数进制转化
    整数位单独算
17. 数据类型
    在计算机中，是以二进制形式来存储数据，每一位二进制在内存中称之为是一“位”（bit， 简写为b），8位 = 1 字节（byte，简写B ），1024B= 1KB ->MB  ->GB  ->TB
    byte b1 表示的数字范围为-128 ～ 127

    基本数据类型
     - 数值型
        * 整数型
          byte  -- 1个字节型 表示的数字范围为-128 ～ 127
          short -- 短整形 2个字节，16位二进制，-2^15 ~ 2^15-1  -> -32768 - 32767
          int   -- 整形 4个字节，  -2^31 - 2^31 - 1;在java中整数默认为int类型; System.out.println(5)
          long  -- 长整型 8个字节， -2^63 - 2^63 - 1, 需要在结尾添加l/L作为标识
     - 浮点型
        * float   单精度 --- 4 个字节 ；-10^38 - 10^38 ,需要在结尾中添加f/F作为标识
        * double  双精度 --- 8 个字节 ；-10^308 - 10^308，在java中小数默认位double
     - char    --- 2个字节  0～65535; 字符在存储过程中需要按照某种规则转化为数字，这种转化规则称之为编码。记录编码形成的表格形式称之为编码表 ---码表
               gbk 两个字节表示一个中文字符 --- 表示绝大部分的常见的简体汉字以及一部分的繁体汉字
               Unicode 编码体系： utf-8  --- 3个字节表示一个字符； utf-16 --- 2个字节表示1个字符
     - 转译字符
       制表符 '\t'; 会车 '\r'; 换行 '\n'; 斜杠 '\\'
     - boolean --- 布尔型 --- true/false  
               
    引用数据类型
     - 数组
    
18. 数据类型的转化
    自动转化
    - 小的类型可以自动转化为大的类型
    - long类型 -- 如果一个整数在int的范围内，那么在赋值给long类型的时候可以不加l / L
    - 整数可以自动转化为小数，但是可能产生精度损失 
    - 字符可以自动转化为整数  char c = 'i'; int i = c
    - char 与 short不能互相转化
    
    强制转化
    - int i = 5; byte b = (byte)i;表示将变量i强制转换为byte类型之后再赋值给变量b 
    - 大类型可以强制转化为小类型，但是在转化的时候因为字节的损失，所以可能导致数据不准确
    
19. 运算符
    - 算数运算符
      + - * / %
      byte / char /short 在参与运算的时候会自动提升为int； byte i = 3, j = 4; byte k = i + j; 会出错误
      两个字面量参与运算的时候，java为了提高效率在编译的时候会进行自动的计算过程；byte b = 3 + 5;
      java 是一门； int i = 4500; i = i / 1000 * 1000 ; 结果i位4000，整形经过乘除依然是整型
      小类型和大类型同时运算，结果一定是大类型
      小数运算不保证精确性
      % 取余---结果的符号和%左边的数字的符号有关，在算的时候，先根据两个数的绝对值来计算。如果%左边为正，则结果为正，如果%为负则为负； 89 % -7 = -5；
    - 赋值运算符
      = += -= 
      int i = 5; i += i -= i /= 5;在运算的时候从左往右编译，在计算结果的时候从右往左； 编译后 i = 5 + (5 - (5 / 5)) = 9
      int i = 5; i = i++ ;最终结果为5；赋值计算靠后
    - 关系运算符
      ==  !=  >=  <= 
    - 逻辑运算符
      & ||  |  &&  ^ 
    - 位运算符
    - 三元运算符

20. 运算符的优先级
    
21. 补码
    - 原码： 二进制码
    - 反码： 正数的原反补三码一致；负数的反码实在原码的基础上，最高位不变，其余为0->1, 1->0;
    - 补码：计算机中存储的是补码; 负数的补码是在反码的基础上+1
    - 1000 0000 规定用-0表示当前类型的最小值；表示的是byte类型 也就是 -128

22. 数组
    - 存储同一类型的多个数据的容器 -- 数组 --- 大小固定
    - 定义格式 -- 数据类型[] 数组名 = new 数据类型[长度] int[] arr = new int[5] ;  double[] arr2 = new double[3]
    - arr[2] = 10 ; int[] arr = new int[]{1, 2, 3, 4, 5}

23. 数组内存问题
    - java 将占用的内存分为了5块： 栈内存、堆内存、方法区、本地方法栈、PC计数器（寄存器）
    - 栈内存：存储的变量，变量在声明的时候存储到栈内存中，不会自动给值，除非在程序中手动给值。变量在栈内存中使用完成之后要立即释放。
    - 堆内存：存储的是对象。对象在存储到堆内存之后，会被堆内存赋予一个默认值： byte/short/int -> 0;  long -> oL; double -> 0.0
    - boolean 对应false char-> '\u0000' 是空字符；除了基本类型，其他对应的默认值都是null；对象使用完成不一定会从堆内存中立即移出，而是在不确定的某个时刻被回收。
    - int[] arr = new int[3] arr存储到栈内存，int[3] 在堆内存中开辟地址；栈内存arr的值是对内存的引用地址；堆内存默认的值是0

24. 时间复杂度
    - 找重复执行的这段代码，将这段代码的执行时间认为是单位1，那么执行这个单位1的次数就是时间复杂度 --> 习惯上，只考虑v最高阶，不考虑系数  ---用O()表示
    - log n 底数默认为2
    - 时间复杂度不决定时间的长短，决定的事次数的多少
25. 空间复杂度
    - 在已知条件下，执行这段代码所需要额外耗费的空间的数量就是空间复杂度

26. 数组的复制
    - arr1 = Arrays.copyOf(arr1, 5) ; 数组的扩容本质上就是数组的复制
    
27. 方法
    - 修复符 返回值类型 方法名
    - 重载: 方法名相同、参数列表类型、个数不同
    - 递归
28. java多行注释不能嵌套；一个类产生一个字节码
29. new class(); 对象是如何在内存中存储的
    - 如果在类中没有手动制定构造方法，那么在编译的时候自动添加一个默认的无参构造方法；构造方法的特点：与类同名，没有返回值类型
    - 作用：用于创建对象
    - 构造方法可以重载
    - @SuppressWarnings --- 用于压制警告
    - this(name, id); 必须放在构造方法的首行
    -  构造代码块： 初始化代码块 无论哪个构造方法执行，都会依次执行，会在构造方法之前执行；和构造方法定义位置先后无关
30. 局部代码块，定义在方法中的代码块
    - 限制了变量的使用范围和生命周期 
    - 内存会提前释放，以提高栈内存的利用率
    
31. 面向对象的特征、
    - 封装、继承、多态、（抽象）
    - 封装体现形式：方法、属性的私有化、内部类
    - 继承把相同的属性和方法提取到一个新的类中，然后利用extends产生联系，子类在继承父类的时候继承了父类的全部数据，但是只有一部分的数据堆子类可见
        * 一个子类只能继承一个父类，一个父类可以有多个子类，
        * java为啥不能用多继承 ———— 
        * 多继承与单继承的优劣性比较：多继承能比单继承更好的提高代码的复用性；在Java中继承了同一个方法，会产生歧议，不知道调用那个，返回值是什么类型
        * super语句必须放在子类构造方法的第一行，所以super（）与 this（）不能同时出现
    - 权限修饰符（大学宿舍的东西）
                            本类中               子类中                同包类中             其他类中
        * public             可以                可以                  可以                 可以
        * protected          可以                可以                  可以                 不可以
        * default            可以                同包子类可以           可以                 不可以
        * private            可以                不可以                不可以                不可以
        * protected那个子类对象调用必须在对应的子类中
        private < 默认 < protected < public

32. 方法重写
    - 子类和父类存在方法签名一样的方法，调用的是子类的方法
    - 子类方法的权限修饰符的范围要大于等于父类对应方法的权限修饰符的范围
    - 方法签名相同
    - 如果父类方法的返回值类型是基本类型 || void， 那么子类重写的方法的返回值类型要和父类一样
    - 如果父类方法的返回值类型是引用类型，那么子类重写的方法的返回值类型要么和父类返回值类型一致，要么是父类方法返回值类型的子类。
    - 基本类型的大小指的是范围的大小 --- 所有的基本类型都是平等的，没有继承关系
    - 是非静态方法

33. 多态
    - 编译时多态
        * 方法的重载
    - 运行时多态 --- 基于继承
        * 向上造型，在编译期间不去确定这次创建对象用的是哪一个子类，只关心创建对象的类和声明对象的类是否有继承关系
        * 父类声明对象，父类创建对象
        * Pet p = new Cat() 
        * 利用向上造型创建的对象，能干什么看的是父类；具体执行看到的是子类。

34. 静态变量的使用
    - static
        * 是一个修饰符，可以修饰变量、方法、代码块、内部类
        * 修饰变量，--- 静态变量
        * 栈内存、堆内存、方法区
        * Java文件 编译成 -> class文件，存放到方法区；方法区先加载核心类库；主函数存放到方法区，主函数到栈内存中执行；方法区有两块内容，一块存储静态属性，一块存放非静态属性
        * 静态属性也会被初始化默认值。静态属性先被加载，堆内存存储的属性指向静态属性的地址；静态属性存放到方法区；
        * 由于静态变量先于对象出现，所以可以通过类名来调用静态变量
        * 类是加载到方法区的 --- 类中的所有的信息都会加载方法区中
        * 类是第一次使用的时候加载到方法区，加载之后不再移除 --- 意味着类只加载一次
        * 也可以通过对象来调用静态属性
        * system.out 、 system.in 都是静态变量
        * 静态变量不能定义到构造方法中；静态变量在加载的时候 加载到方法区，构造方法是在创建对象的时候调用，在栈内存中运行
        * 静态变量也不能定义到构造代码块中 ---  
        * 所有的静态只能定义在类中，不能定义到代码块中，方法也是特殊的代码块
      静态方法
        * 用static修饰的方法，也叫类方法，随着类的加载而加载到方法区，只是存储在方法区中，在被调用的时候到栈内存中执行。静态方法先于对象存在的，所以习惯上通过类名来调用静态方法
        * 在静态方法中能否直接使用本类中的非静态属性活着非静态方法？ ---不可以，
        * 静态方法中能否定义静态变量？ --- 不可以。静态变量是在类加载的时候加载到方法区，静态方法在调用的时候才执行，并且是在栈内存中执行。
        * 静态方法可以重载吗？ --- 可以
        * 静态方法可以被继承吗？--- 可以
        * 静态方法可以被重写吗？--- 不可以
        * 父子类中是否可以存在方法签名一致的静态方法？ --- 可以 ---构成隐藏，执行的是声明类中的方法(多态) A a = new B(); a.m();
        * 父子类中只要存在方法签名一致的方法，要么都是非静态（重写），要么都是静态（隐藏）
      静态代码块
        * 用static 修饰的代码块；
        * 只在类第一次被使用的时候执行一次
        * 类只加载一次，因此静态代码块也只执行一次
    - final 也是一个修饰符，修饰数据、方法、类
      修饰变量
        * final修饰数据，使其成为常量 --- 值不可改变 
        * 常量可以先声明后给值。
        * 如果是常量属性，需要在对象创建完成之间给值。在构造代码块活着构造函数给值。
        * 静态常量要求在类加载完成之前给值；可以给静态代码块给值。
        * arr.length; System.out; System.in 都是常量
      修饰方法
        * 不能被重写/隐藏，可以被继承
      修饰类
        * 不能被继承
        * System、String 类就是final类
      
    - abstract 抽象
       * 修饰符
     抽象类
       * 当一个类继承了抽象类之后要重写抽象类中的抽象方法
       * 内部类也会产生一个字节码
       * 抽象类不能创建对象，依然有构造方法
       * 不能被final修饰
       * 抽象类不一定有抽象方法，
       * 可以有其他属性和方法。
     抽象方法
       * 抽象方法必须存在抽象类中
       * 抽象方法可以被重载
       * 一定被重写
       * 不能用static修饰抽象方法
       * final不能修复抽象方法
       * private 不能修复抽象类的抽象方法
       * 如果抽象方法使用默认权限，要求父子类同包
    - interface
       * 如果一个类中的所有方法都是抽象方法，那么可以把这个类声明为一个接口
       * JDK1.8以后可以定义实体方法
       * 不允许创建对象
       * 接口不能够有构造方法
       * 接口不是类， 通过implements 实现
       * 一个子类只能继承一个父类，能实现多个interface；并且多个接口存在方法签名一致的情况，会导致方法重写的时候产生冲突
       * interface可以继承接口，并且接口之间是多继承
       * 在Java中类和类之间是单继承，所以形成了一棵继承结构树， 所以在编译的时候回去检查类和原类型之间是否有继承关系，到运行的时候确定对象实际类型和转化的类型，类型一致，就允许转换
       * 任何一个对象可以用任何一个接口进行强转而编译不报错；到运行的时候要检查这个类和接口之间是否真正有实现工作
       * interface里面的属性默认是static类型、final、public
       * interface里面的方法默认是用public修饰的
    - interface JDK1.8以后
       * 接口中允许定义实体方法 --- 默认方法和静态方法。
       * 接口中要定义实体方法，需要将该方法用default修饰；静态方法不用default
       * 如果一个接口只有一个抽象方法，那么这个接口可以声明为函数试接口
         @FunctionalInterface
         interface ArrayUse {
           double ascSort(int[] arr);
         }
    - 内部类
       * Lambda表达式
           Calculator  c = (double i, double j) -> {
               return i + j;
           }
           Calculator  c = (i, j) -> i + j;
       * 匿名内部类
           Calculator c = new class() {}
         1. 匿名内部类实际上是实现了对应的接口
         2. 匿名内部类实际上是对应类的子类活着对应接口的实现类
         3. 任何一个接口都可以存在匿名内部类形式
         4. 任何一个类只要可以被继承，就可以存在匿名内部类的形式
       * 方法内部类 || 局部内部类
         1. 只能在定义她的方法中使用
         2. 在方法内部类中，不能定义静态变量和静态方法，但是可以静态常量
         3. 可以使用外部类中的属性和方法
         4. 内部类访问外部类同名属性；外部类.this.同名属性
         5. 方法内部类在使用当前方法中的数据的时候，要求这个数据是一个常量
         6. 方法内部类只能用abstract / final修饰
         7. 保证代码既能够重复使用又只属于特定的方法
       * 成员内部类
         1. 定义在类中的类
         2. 不能直接在本类的静态方法中使用
         3. 可以使用外部类中的一切属性和方法
         4. 不能定义静态变量和静态方法，但是可以静态常量
         5. 属于对象上的属性
       * 静态内部类
         1. 静态内部类只能使用外部类重的静态属性和静态方法 
         2. 静态内部类可以作用在整个类
         3. 可以定义静态属性和静态方法
       * 扩展：在类中定义类和接口，在接口中 可以定义类和接口，类中的接口必须是静态的
    - 包
       * 声明包用的是package，导入包用的是import
       * 一个java包只能定义一个包，而且package语句必须放在文件第一行
       * import用于表示导入使用的类的所在路径
       * import java.util.*; // 表示导入util包下所有的类，单不包括子包下的类
       * \* 表示一个通配符，表示导入当前包下所有类而不包括子包下的类
       * java.util工具包，提供了一系列的便捷操作的工具类
       * java.lang 基本包，提供java运行所需要的基本类，这个包中的所有类在程序启动的时候就已经自动加载到内存中
       * java中什么时候不用导包？---java.lang和同包类
       * 在声明包的时候尽量不要使用java/javax/org
       * java.awt ---GUI包
       * java.io ---数据传输
       * java.math --- 数学运算
       * java.nio  --- 高并发
       * java.net --- 网络编程
       * java.text ---格式化
       * java.sql 和数据库交互的包
    - 垃圾分代回收机制
       * 垃圾回收针对堆内存的
       * 在Java中，每一个类型的大小都是固定的，所以所有的内存都由java来自动分配，也是自动回收的
       * 垃圾收集器（garbage collector -- GC）
       * 对象在使用完成之后不一定立即回收而是在不确定的某个时刻回收--- 当堆内存的使用率超过70%的时候，GC才会启动回收
       * 新生代
         1. 伊甸园去
         2. 幸存区
      
       * 老生代
       * 将堆内存划分为新生代和老生代，将新生代划分为伊甸园去和幸存区。对象刚创建的时候放到伊甸园去，在伊甸园去经过一次扫描，如果对象依然存在则挪到幸存去。如果在幸存去中经过多次扫描依然存在，则
         挪到老生代。老生代扫描频率远低于新生代。老生代的对象一旦产生回收可能会导致程序的卡顿甚至崩溃。
       * 发生在新生代的回收 --- minor gc（初代回收）
       * 发生在老生代的回收 --- full gc （完全回收）
       * 内存标记发生了改变，而不是内存发生了改变
















































