# 线程/进程
    进程：计算机中在执行的任务  --- 在cpu上执行和计算
    线程：进程中的小任务。
    注意：一个核上往往只能执行一个进程中的一个线程。--- 计算机看起来是在运行多个进程，实际上
        是因为在计算机中任务切换速度非常快，超过人的反应。--- 进程的执行在宏观上并并行的，在微观上
        是串行的。

1. 定义线程
    - Thread 父类
    - 写一个类继承Thread,将要执行的逻辑放到run方法中，创建线程对象，调用start方法来启动线程执行任务
    - 

2. 写一个类实现Runnable接口
    - 重写run方法，创建Runnable对象，然后将Runnable对象作为参数传递到Thread对象中
    - 利用Thread对象来启动线程

3. 写一个类实现Callable接口，重写call方法。 --- 
    - 以后说

4. 多线程的并发安全问题
   - 多个线程同时执行，而多个线程在执行的时候是相互抢占资源导致出现了不合理的数据的现象 --- 多线程的
   - 并发安全问题
   - 注意：多线程在执行的时候是相互抢占，而且抢占时发生在线程执行的每一步过程中

5. 同步锁机制
   -  同步 --- 一段逻辑在同一时间只能有一个线程执行
   -  异步 --- 一段逻辑在同一时间有多个线程执行
   -  同步一定是安全的吗  是
   -  安全一定是同步的吗  不是
   - 异步不一定不安全
   - 不安全一定是异步的
   - HashMap 是一个异步线程不安全的
   - HashTable 是一个同步线程安全的
   - ConcurrentHashMap 是一个异步式线程安全的
   - 从微观上而言，同步一定是安全的，安全也一定是同步的
   - 从宏观上，同步一定是安全的，安全不一定是同步的
   - 锁对象 --- 要求锁对象要被所有的线程都认识：共享对象
   - 死锁现象 解决了; 避免死锁，统一锁对象，减少锁的嵌套
   - 活锁 --- 这个资源没有被任何的线程持有占用，导致程序无法往下执行（互相谦让，不占据资源）
   - 等待唤醒必须利用同步锁，而且锁对象是谁，就利用谁等待唤醒
   - notify notifyAll
   - wait
   - Thread.sleep
   - Thread.currentThread.getName()
   - ThreadInstance.getPriority()
6. 扩展
   - 堆内存、方法区是被线程共享的
   - 栈内存、本地方法栈、PC计数器是每一个线程所独有的
   - 创建 -> 就绪 -> 阻塞/挂起 -> 消亡
                 -> 运行/活跃 -> 消亡 // 挂起只能转就绪，不能变位活跃
                                   // 活跃可以变位挂起
   - 线程是互相抢占资源，可以给线程配置优先级
   - 线程的优先级：1-10 ；理论上数字越大优先级越高，抢占到资源的概率就越大
   - 实际上，相邻的两个优先级的差别非常不明显
   - 如果优先级差到5个单位及以上，则结果会相对明显一点点

7. 守护线程
   - 守护别的线程，只要被守护的线程结束了，守护线程无论完成与否，都要消亡
   

































