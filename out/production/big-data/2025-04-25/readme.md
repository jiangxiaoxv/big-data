# 集合 --- Collection --- 是一个根接口
    - 存储多个元素的容器 --- 大小不固定
    - Collection<E> --- 集合顶级接口<E> ---泛型 --- 在集合中，泛型用于定义元素类型
    - 由于泛型的限制，集合中只能存储对象
    - Collection<String> c = new ArrayList<String>();
    - 存放同一种类型的元素

1. Collections 工具类
   - 操作集合的工具类
   - sort用于列表进行排序，在排序的时候可以默认生序排序，也可以自定义排序规则。在指定规则的时候
   - 需要传入一个Comparator（比较器）对象，重写compare方法，根据返回值的正负来对元素进行排序
   - iterator 迭代器
   
# List
1. List 也是一个接口
   - 元素有序 --- 保证元素的存入顺序 --- list中的元素是存在下标的
2. ArrayList
    - 底层用数组存储数据。默认初始容量是10，每次扩容是在当前的基础上增加一半；10 -> 15 -> 22
    - 内存空间是连续的
    - 增删元素的操作相对复杂
    - 查询元素的操作相对简单
    - 是一个线程不安全的集合
    - 
3. LinkedList 链表
   - 底层是基于节点来进行存储的，内存空间不连续
   - 增删元素相对简单
   - 查找元素比较复杂
   - 是一个线程不安全的集合
4. 顺序表和链表在增删操作时的效率如何？
   - 在增删次数和查询次数相差不大的时候，使用链表结构
   - 原因是链表对内存的要求更小
   - 整体效率上，链表要高于顺序表。如果增删位置相对靠前，那么链表效率较高
   - 如果增删位置相对考后，则顺序表效率较高


5. Vector --- 向量
   - 最早的集合。底层是基于数组进行存储的。默认初始容量是10；默认扩容增加一倍
   - 是一个线程安全的集合
   - elements();返回此向量的组件的枚举，是一个迭代器
   - nextElement
   - hasMoreElement
   - 
6. Stack --- 栈
   - 表示后进先出，先进后出的原则
   - 继承了Vector
   - LIFO --- last in first out
   - FILO --- first in last out
   - 最先放入栈中的元素 --- 栈低元素

# Set 散列集合
   - set中的元素不可重复
1. HashSet 是set的实现类
   - 由hash表支持实现，不保证set的迭代顺序
   - 不保证已放入的数据顺序恒久不变
   - 底层是基于hashMap来存储的
   - hashMap底层是基于数组+链表来存储的，初始容量是16，加载因子默认是0.75f
   - 在这个数组中的每一个位置称之为桶---bucket，初始是16个桶
   - 在存放数据的时候，先计算元素的哈希码---针对这个哈希码再做二次运算，使运算的结果随即散落在这些桶中的某个桶里
   - 桶里存放的是数据的地址，同一个桶里可以是一个栈的链表结构
   - 已经使用桶的数量/桶的总数量 > 加载因子， 那么就需要扩容;每一次扩容都是当前基础上增加一倍
   - 扩容之后将集合中的所有的元素重新计算哈希码重新分布---rehash
   - 加载因子越小，会导致rehash操作越频繁，会导致内存的浪费
   - 加载因子过大，会导致每一个桶中的链表过长从而降低效率
   - 内存存储的时间复杂度是logn
   - 从jdk1.8开始，为了减少扩容次数同时也为了保证每一个桶的查询效率，在桶中的元素超过8个的时候，会采取红黑树结构
   - 

# Iterable
   - 实现该接口所产生的对象可以被增强for循环进行遍历。 --- 如果一个对象能够使用
   - 增强for循环，那么这个对象对应的类要实现Iterable接口
   - 增强for循环，本质上是一个迭代遍历
# Iterator 迭代器。
   - 在迭代过程中会对每一个元素进行标记。如果标记状态为false说明该元素要被移除。

# 泛型 --- 参数化类型 -- parma
   - 将泛型替换为具体类型的过程 --- 泛型的擦除，发生在编译的时候
   - 集合不存在继承的问题；所以 不能这样定义 List<Object> list = new ArrayList<String>()
   - 前后要保持一样，<Object> 和 <String>要一直

# Stream
   - 用于操作集合的流式结构，但不是流。利用stream对象对集合进行批量操作

# 断言
   - 对已经发生的事进行断言，根据已有条件，来对结果进行预测断定。如果实际结果和预测一致，则断言成功
   - 在java中，断言不是默认开启的，需要手动开启 -ea
   - 断言成功继续运行，断言失败，代码不在继续运行。

# Map --- 映射
   - 键 - key， 值 - value； --- 键是唯一的，每一个键对应了一个值，键值对
   - 每一个键值对可以看做对象，可以认为一个map对象是由多个键值对对象组成。
   - 对象是由多个entry对象组成
1. hashMap
   - Map.Entry<T,E>
   - keySet()
   - entrySet
   - 映射不是集合，但是集合框架的一员
   - Map是顶级接口，但是Dictionary 是顶级父类
   - HashMap 是Map的实现类，同样也是基于数组和链表一起实现
   - 本身是一个异步式线程不安全的；
2. hashTable
   - 键和值都不能是null
   - 默认初始容量是11 ，默认加载因子是0.75f
   - 本身是一个同步式线程安全的映射
   - 线程不安全效率高于线程安全的
   
3. CurrentHashMap --- 异步式线程安全的映射

# JDK1.5特性
1. 自动封箱/拆箱 增加for循环 静态导入
2. 可变参数  枚举  泛型  反射  动态代理  内省  注解

# 静态导入/静态导出
1. import static 包名.类名.方法名；表示导入制定包下的指定类的指定的静态方法而不导入其他方法
2. import static java.util.Arrays.sort; sort([])
3. 理论上能够提高加载速率 ，这个提高程度忽略不计
4. 带来程序可阅读性大大降低，如果本类或者父类中存在方法签名一致的方法会导致静态导包失效




























